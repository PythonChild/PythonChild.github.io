<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="（Cpp篇）谈谈class的相关知识"><meta name="keywords" content="class、struct、friend、etc..."><meta name="author" content="Youngton"><meta name="copyright" content="Youngton"><title>（Cpp篇）谈谈class的相关知识 | Youngton</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、前话"><span class="toc-number">1.</span> <span class="toc-text">一、前话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、class是什么？"><span class="toc-number">2.</span> <span class="toc-text">二、class是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、class的实现及基本特性"><span class="toc-number">3.</span> <span class="toc-text">三、class的实现及基本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、封装"><span class="toc-number">3.1.</span> <span class="toc-text">1、封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、继承"><span class="toc-number">3.2.</span> <span class="toc-text">2、继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、多态"><span class="toc-number">3.3.</span> <span class="toc-text">3、多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、深入谈class"><span class="toc-number">4.</span> <span class="toc-text">四、深入谈class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、定义一个类时，系统会为我们做些什么？"><span class="toc-number">4.1.</span> <span class="toc-text">1、定义一个类时，系统会为我们做些什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、多态如何实现？"><span class="toc-number">4.2.</span> <span class="toc-text">2、多态如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、静态成员变量、静态成员函数"><span class="toc-number">4.3.</span> <span class="toc-text">3、静态成员变量、静态成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、后话"><span class="toc-number">5.</span> <span class="toc-text">五、后话</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/MyImage.jpeg"></div><div class="author-info__name text-center">Youngton</div><div class="author-info__description text-center">法苏最可爱，不接受反驳</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/background_fs.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Youngton</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">（Cpp篇）谈谈class的相关知识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-12</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="一、前话"><a href="#一、前话" class="headerlink" title="一、前话"></a>一、前话</h2><p>在许多人的印象中，谈起<code>C++</code>，就想到<code>C++</code>的三个特性：<strong><code>封装</code></strong>、<strong><code>继承</code></strong>、<strong><code>多态</code></strong>（其实这里面还有第四个特性，即<strong><code>抽象</code></strong>），而与这些特性有直接关联的便是<strong><code>class</code></strong>这样一个数据结构。所以，掌握<code>C++</code>，不可绕过的一个知识点，就是学会<code>class</code>以及如何运用它！因此，本文着重讲解<code>class</code>的特点，以及相关扩展！</p>
<h2 id="二、class是什么？"><a href="#二、class是什么？" class="headerlink" title="二、class是什么？"></a>二、class是什么？</h2><p><code>class</code>是什么？带着这个问题，我这里先给出WiKi的定义：</p>
<p><code>class</code>在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的<strong>属性</strong>和<strong>方法</strong>。</p>
<p>这里有两个名词需要先说明一下：</p>
<ul>
<li>父类：就是被继承的类（class）</li>
<li>子类：相对名字，该类继承谁，那就是谁的子类，相反，被继承的类也是该类的父类（有些地方叫超类）</li>
</ul>
<p>那么我谈谈自己对这四个特性的一些见解：</p>
<ul>
<li><p>对象共同的<strong>属性</strong>和<strong>方法</strong>：表明了<code>class</code>的<strong>抽象</strong>性质，即把事物的共同性质提取出来，放在同一个数据结构中，恰巧这个数据结构就叫做<code>class</code></p>
</li>
<li><p>由于一个<code>class</code>里面，即包含其<strong>属性</strong>（成员变量）和<strong>方法</strong>（成员函数），而且<code>class</code>自身也有对外可见/不可见的性质，因此很好的体现了<strong>封装</strong>这一特点</p>
</li>
<li><p>由于<code>class</code>中的<strong>属性</strong>与<strong>方法</strong>是一类事物的共同性质（特征），因此在该类下的小类事物，可以将已有的<strong>属性</strong>和<strong>方法</strong>加以利用，因此<strong>继承</strong>也就非常明了了</p>
</li>
<li><p>在<strong>继承</strong>的基础上，同一大类下的不同小类事物可能对某些方法的表达存在差异，例如：</p>
<p><code>两种交通工具：飞机和高铁，他们有一个共同的方法，那就是运输，但两者运输实现细节有差异，飞机是在天上飞，高铁是在铁路上跑，这就是同一方法，但具有不同的实现细节</code></p>
<p>上述的例子，便是对<strong>多态</strong>的解释。</p>
</li>
</ul>
<p>到此，我相信大家对<code>class</code>这个数据结构，有了大概的了解，那么我们就可以开始逐一深入了解！</p>
<h2 id="三、class的实现及基本特性"><a href="#三、class的实现及基本特性" class="headerlink" title="三、class的实现及基本特性"></a>三、class的实现及基本特性</h2><p>首先，我们抛开所有性质，先单纯看看一个类是怎么实现的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类 A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A();				<span class="comment">// 构造函数，下面会详细介绍</span></span><br><span class="line">    	~A();				<span class="comment">// 析构函数，下面会详细介绍</span></span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span>			<span class="comment">// 直接类内实现</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;		<span class="comment">// 类外定义的函数，需要加分号</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">&#125;;	<span class="comment">// 注意类的定义最后需要一个分号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> A::fun2()	<span class="comment">// 类外定义的函数，格式为 返回类型 类名::函数名</span></span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对类的定义和实现有一个大概的了解，我们再谈谈类的特性。</p>
<h3 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h3><p>在类中，<code>C++</code>定义了三个关键字，已起到类的<strong>封装</strong>特性，它们分别是：<code>private</code>、<code>public</code>、<code>protected</code></p>
<ul>
<li><code>private</code>修饰的<strong>属性</strong>和<strong>方法</strong>都只能被本类自身方法调用，用户实例化一个类（实例化：即生成一个类变量），对于经过<code>private</code>修饰的<strong>属性</strong>和<strong>方法</strong>都无权限调用，如果想调用，只能通过<code>public</code>修饰的<strong>方法</strong>去调用。</li>
<li><code>protected</code>修饰的<strong>属性</strong>和<strong>方法</strong>只能被本类以及其子类所调用（当然前提是子类继承该类的方式是<code>protected</code>或<code>public</code>继承），用户无权限调用，若想调用，与上面方式一样</li>
<li><code>public</code>修饰的<strong>属性</strong>和<strong>方法</strong>，可以说是对用户完全开放的，用户可以随意调用，对于<strong>属性</strong>，甚至可以修改它们，所以对程序安全有着一定的威胁。</li>
</ul>
<p>在这里，我们顺带一提一个破坏类的<strong>封装</strong>特性的关键字：<code>friend</code>，中文称友元，<code>friend</code>修饰的函数（该函数不是类定义的函数，是类外定义的函数），可以访问类的任何属性，<code>private</code>对其来说，就像透明一样，所以建议少用或者干脆不用！</p>
<p>代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公共的属性或者行为</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;		<span class="comment">// 友元函数</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="comment">// 私有的属性或者行为</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 保护的属性或者行为</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h3><p>继承也分为：<strong>私有继承</strong>、<strong>公有继承</strong>、<strong>保护继承</strong></p>
<ul>
<li><strong>私有继承：</strong>当类的继承方式为私有继承时，基类中的公有成员和保护成员都以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可访问。基类的公有成员和保护成员被继承后作为派生类的私有成员，派生类的其他成员可以直接访问它们，但是在类外部通过派生类的对象无法访问。无论是派生类的成员还是通过派生类的对象，都无法访问从基类继承的私有成员。通过多次私有继承后，对于基类的成员都会成为不可访问。因此私有继承比较少用。</li>
<li><strong>公有继承：</strong>当类的继承方式为公有继承时，基类的公有和保护成员的访问属性在派生类中不变，而基类的私有成员不可访问。即基类的公有成员和保护成员被继承到派生类中仍作为派生类的公有成员和保护成员。派生类的其他成员可以直接访问它们。无论派生类的成员还是派生类的对象都无法访问基类的私有成员。</li>
<li><strong>保护继承：</strong>保护继承中，基类的公有成员和私有成员都以保护成员的身份出现在派生类中，而基类的私有成员不可访问。派生类的其他成员可以直接访问从基类继承来的公有和保护成员，但是类外部通过派生类的对象无法访问它们，无论派生类的成员还是派生类的对象，都无法访问基类的私有成员。</li>
</ul>
<p><strong>注意：</strong>作为父类，其析构函数最好写成<strong>虚函数</strong>（下面会介绍）！！</p>
<p>其具体代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FatherClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassA</span> :</span> <span class="keyword">private</span> FatherClass		<span class="comment">// 私有继承</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassB</span> :</span> <span class="keyword">public</span> FatherClass		<span class="comment">// 公有继承</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassC</span> :</span> <span class="keyword">protected</span> FatherClass		<span class="comment">// 保护继承</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h3><p>所谓多态，是在继承的基础上实现的，抛开类的定义，我们都知道，<code>C++</code>中有<strong>函数重载机制</strong>，而在类中，同一方法的不同实现细节则称为<strong>重写</strong>，这里需要提到一个概念：<strong>虚函数</strong>，关键字为<code>virtual</code></p>
<p>当出现<strong>多态</strong>时，基类的需要发生<strong>重写</strong>的成员函数，必须声明为<strong>虚函数</strong>，声明方式如下：</p>
<p><code>virtual void func();</code></p>
<p>只有这样子，当我们实例化一个有父类指针指向子类的变量，亦或是父类引用子类的变量，再调用函数时，若出现<strong>重写函数</strong>，才能正确调用，正确体现多态！</p>
<h2 id="四、深入谈class"><a href="#四、深入谈class" class="headerlink" title="四、深入谈class"></a>四、深入谈class</h2><p>经过上述的讲解，相信大家对一个类如何定义、如何实现，有什么基本性质都有一个比较详细的学习，那么接下来，我们针对其中的细节，畅谈一番！</p>
<h3 id="1、定义一个类时，系统会为我们做些什么？"><a href="#1、定义一个类时，系统会为我们做些什么？" class="headerlink" title="1、定义一个类时，系统会为我们做些什么？"></a>1、定义一个类时，系统会为我们做些什么？</h3><p>在我们定义一个空类时，即任何属性、方法没有，系统会自动为我们生成4个函数：<strong>默认缺省构造函数、拷贝构造函数、析构函数、赋值运算符</strong></p>
<p>首先，我们需要对以上几个函数要用一个认识！</p>
<ul>
<li><strong>构造函数：</strong>主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，同一个类的构造函数可以有多个，若不声明，那系统会自动生成一个无形参（缺省）的默认构造函数。</li>
<li><strong>析构函数：</strong>与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）。</li>
<li><strong>拷贝构造函数：</strong>又称复制构造函数，是一种特殊的构造函数，它由编译器调用来完成一些基于同一类的其他对象的构建及初始化。<strong>其唯一的形参必须是引用，倘若不为引用，会陷入死循环，程序直接崩溃，但并不限制为<code>const</code>，一般普遍的会加上<code>const</code>限制</strong>。此函数经常用在函数调用时用户定义类型的值传递及返回。</li>
</ul>
<p>说这么多，没有代码实现的话，看的也会是一头雾水！让我们看看代码如何实现！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/* 系统自动生成以上所说的四个函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1;		<span class="comment">// 实例化一个类变量，自动调用默认构造函数</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(a1)</span></span>;	<span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    A a3 = a1;	<span class="comment">// 调用赋值运算符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 当程序结束运行时，系统自动调用析构函数释放变量的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然倘若我们自己想要去实现以上函数，代码应该这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A(<span class="keyword">const</span> <span class="keyword">int</span> Temp);			<span class="comment">// 构造函数</span></span><br><span class="line">    	A(<span class="keyword">const</span> A&amp; a);				<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    	~A();						<span class="comment">// 析构函数</span></span><br><span class="line">    	A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; a);	<span class="comment">// 重载赋值运算符</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、多态如何实现？"><a href="#2、多态如何实现？" class="headerlink" title="2、多态如何实现？"></a>2、多态如何实现？</h3><p>在前面，已经讲解了如何从代码层去实现类的多态，那这里我们就深入一点，看看底层为多态做出了哪些努力。</p>
<p>我们知道，如果要实现多态机制，那么必须将父类的某个将要实现多态的成员函数写为<strong>虚函数</strong>，这时，父类以及继承自它的子类都会生成一个虚函数表，而每个类都有一个虚函数指针指向这个表，虚函数表中存放的是父类的虚函数地址，以及子类经过重写的虚函数地址。</p>
<p><strong>这里要注意一点是：</strong>子类中不仅有自己重写过的虚函数，而且还包含了父类的虚函数地址，当发生行为多态时，系统是从这个虚函数表去判别应该执行哪个函数。而且，虚函数表的大小不占用到类的空间，类中只分配内存给指向虚函数表的虚函数指针！</p>
<h3 id="3、静态成员变量、静态成员函数"><a href="#3、静态成员变量、静态成员函数" class="headerlink" title="3、静态成员变量、静态成员函数"></a>3、静态成员变量、静态成员函数</h3><p>在类中，采用<code>static</code>修饰的成员变量，我们称为静态成员变量，与非静态成员变量不一样，静态成员变量是属于类的，不属于实例化对象，因此在任何使用周期中，都只有一份拷贝，而且对于静态成员变量，我们必须在类定义时，将其初始化！</p>
<p>同样，在类中，采用<code>static</code>修饰的成员函数，我们称为静态成员函数，使用这样的函数，我们不需要去实例化一个对象，然后通过对象去使用该函数，可以通过作用域符<code>::</code>直接使用，如<code>class::statciFun()</code>，当然通过常规方式去使用也是可以的，但效果都一样。</p>
<p>但是对于静态成员函数，它不可以直接访问非静态成员变量，这里很好理解，非静态成员变量在未实例化一个对象时，它根本就不存在，函数怎么可以去使用它呢？</p>
<p>而且，对于静态成员变量，它是存放在全局静态区中，因此当你采用<code>sizeof(class)</code>去看一个类的大小时，并不会计算静态成员变量的大小。</p>
<h2 id="五、后话"><a href="#五、后话" class="headerlink" title="五、后话"></a>五、后话</h2><p>如果你认真的看到这里，相信对前面有些许大概的了解，当然，这里讲的还是比较粗糙，需要更加规范、更加全面的讲解，也建议你去看看《C++ Primer Plus》这本书，讲的内容非常齐全，最后也提提几点优化及需要注意的点。</p>
<ul>
<li><p>虚构函数可以声明为虚函数，但构造函数不可以声明为虚函数！通俗点讲，就是虚函数是为多态工作的，而多态是在运行期表现出来的一种行为，但构造函数一般是我们在初始化一个实例，即在编译期就需要确定下来的，这样子就起冲突了，因此构造函数不可以声明为虚函数！</p>
</li>
<li><p>在构造函数中初始化各个成员变量时，若变量不是内置类型（<code>int</code>、<code>float</code>，<code>double</code>等），那么采用<strong>Initialization</strong>(初始化列表)，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="built_in">string</span> a,<span class="keyword">int</span> b):a(a)		<span class="comment">// 初始化列表的形式</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = b;					<span class="comment">// 内置类型可以不采用初始化列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为什么这样做的话，性能可以得到一定的优化？因为对于非内置类型，如<code>string</code>，直接对其赋值，其实在内部，还是会去调用初始化列表对其进行初始化，然后再采用赋值运算符，而直接使用初始化列表就只需要进行第一步！</p>
</li>
</ul>
<p>好了，对于类的基本讲解，我们就点到为止，更多更深的知识还是需要去翻阅书籍，以及自己动手去敲代码！谢谢大家！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Youngton</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/08/12/（Cpp篇）谈谈class的相关知识/">http://yoursite.com/2019/08/12/（Cpp篇）谈谈class的相关知识/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/class、struct、friend、etc/">class、struct、friend、etc...</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/07/26/（Cpp篇）谈谈const与define/"><span>（C/C++篇）谈谈const与#define</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/img/background_fs.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By Youngton</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>